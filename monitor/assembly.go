// Code generated by schema-generate. from CDK CloudAssyemble
// https://github.com/aws/aws-cdk/blob/dfcfb8da34a495987214e70713b0c61f368ce962/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts
// With https://github.com/a-h/generate
// Have to edit the package name to "monitor"

package monitor

import (
    "encoding/json"
    "errors"
    "fmt"
    "bytes"
)

// Root
type Root *AssemblyManifest

// AmiContextQuery Query to AMI context provider
type AmiContextQuery struct {

  // Account to query
  Account string `json:"account"`

  // Filters to DescribeImages call
  Filters map[string][]string `json:"filters"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Owners to DescribeImages call (Default - All owners)
  Owners []string `json:"owners,omitempty"`

  // Region to query
  Region string `json:"region"`
}

// ArtifactManifest A manifest for a single artifact within the cloud assembly.
type ArtifactManifest struct {

  // IDs of artifacts that must be deployed before this artifact. (Default - no dependencies.)
  Dependencies []string `json:"dependencies,omitempty"`

  // A string that represents this artifact. Should only be used in user interfaces. (Default - no display name)
  DisplayName string `json:"displayName,omitempty"`

  // The environment into which this artifact is deployed. (Default - no envrionment.)
  Environment string `json:"environment,omitempty"`

  // Associated metadata. (Default - no metadata.)
  Metadata map[string][]*MetadataEntry `json:"metadata,omitempty"`

  // The set of properties for this artifact (depends on type) (Default - no properties.)
  Properties interface{} `json:"properties,omitempty"`

  // The type of artifact.
  Type string `json:"type"`
}

// AssemblyManifest A manifest which describes the cloud assembly.
type AssemblyManifest struct {

  // The set of artifacts in this assembly. (Default - no artifacts.)
  Artifacts map[string]*ArtifactManifest `json:"artifacts,omitempty"`

  // Missing context information. If this field has values, it means that the
  // cloud assembly is not complete and should not be deployed. (Default - no missing context.)
  Missing []*MissingContext `json:"missing,omitempty"`

  // Runtime information. (Default - no info.)
  Runtime *RuntimeInfo `json:"runtime,omitempty"`

  // Protocol version
  Version string `json:"version"`
}

// AssetManifestProperties Artifact properties for the Asset Manifest
type AssetManifestProperties struct {

  // SSM parameter where the bootstrap stack version number can be found
  // 
  // - If this value is not set, the bootstrap stack name must be known at
  //   deployment time so the stack version can be looked up from the stack
  //   outputs.
  // - If this value is set, the bootstrap stack can have any name because
  //   we won't need to look it up. (Default - Bootstrap stack version number looked up)
  BootstrapStackVersionSsmParameter string `json:"bootstrapStackVersionSsmParameter,omitempty"`

  // Filename of the asset manifest
  File string `json:"file"`

  // Version of bootstrap stack required to deploy this stack (Default - Version 1 (basic modern bootstrap stack))
  RequiresBootstrapStackVersion float64 `json:"requiresBootstrapStackVersion,omitempty"`
}

// AvailabilityZonesContextQuery Query to availability zone context provider
type AvailabilityZonesContextQuery struct {

  // Query account
  Account string `json:"account"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Query region
  Region string `json:"region"`
}

// AwsCloudFormationStackProperties Artifact properties for CloudFormation stacks.
type AwsCloudFormationStackProperties struct {

  // The role that needs to be assumed to deploy the stack (Default - No role is assumed (current credentials are used))
  AssumeRoleArn string `json:"assumeRoleArn,omitempty"`

  // External ID to use when assuming role for cloudformation deployments (Default - No external ID)
  AssumeRoleExternalId string `json:"assumeRoleExternalId,omitempty"`

  // SSM parameter where the bootstrap stack version number can be found
  // 
  // Only used if `requiresBootstrapStackVersion` is set.
  // 
  // - If this value is not set, the bootstrap stack name must be known at
  //   deployment time so the stack version can be looked up from the stack
  //   outputs.
  // - If this value is set, the bootstrap stack can have any name because
  //   we won't need to look it up. (Default - Bootstrap stack version number looked up)
  BootstrapStackVersionSsmParameter string `json:"bootstrapStackVersionSsmParameter,omitempty"`

  // The role that is passed to CloudFormation to execute the change set (Default - No role is passed (currently assumed role/credentials are used))
  CloudFormationExecutionRoleArn string `json:"cloudFormationExecutionRoleArn,omitempty"`

  // The role to use to look up values from the target AWS account (Default - No role is assumed (current credentials are used))
  LookupRole *BootstrapRole `json:"lookupRole,omitempty"`

  // Values for CloudFormation stack parameters that should be passed when the stack is deployed. (Default - No parameters)
  Parameters map[string]string `json:"parameters,omitempty"`

  // Version of bootstrap stack required to deploy this stack (Default - No bootstrap stack required)
  RequiresBootstrapStackVersion float64 `json:"requiresBootstrapStackVersion,omitempty"`

  // The name to use for the CloudFormation stack. (Default - name derived from artifact ID)
  StackName string `json:"stackName,omitempty"`

  // If the stack template has already been included in the asset manifest, its asset URL (Default - Not uploaded yet, upload just before deploying)
  StackTemplateAssetObjectUrl string `json:"stackTemplateAssetObjectUrl,omitempty"`

  // Values for CloudFormation stack tags that should be passed when the stack is deployed. (Default - No tags)
  Tags map[string]string `json:"tags,omitempty"`

  // A file relative to the assembly root which contains the CloudFormation template for this stack.
  TemplateFile string `json:"templateFile"`

  // Whether to enable termination protection for this stack.
  TerminationProtection bool `json:"terminationProtection,omitempty"`

  // Whether this stack should be validated by the CLI after synthesis (Default - false)
  ValidateOnSynth bool `json:"validateOnSynth,omitempty"`
}

// BootstrapRole Information needed to access an IAM role created
// as part of the bootstrap process
type BootstrapRole struct {

  // The ARN of the IAM role created as part of bootrapping
  // e.g. lookupRoleArn
  Arn string `json:"arn"`

  // External ID to use when assuming the bootstrap role (Default - No external ID)
  AssumeRoleExternalId string `json:"assumeRoleExternalId,omitempty"`

  // Name of SSM parameter with bootstrap stack version (Default - Discover SSM parameter by reading stack)
  BootstrapStackVersionSsmParameter string `json:"bootstrapStackVersionSsmParameter,omitempty"`

  // Version of bootstrap stack required to use this role (Default - No bootstrap stack required)
  RequiresBootstrapStackVersion float64 `json:"requiresBootstrapStackVersion,omitempty"`
}

// ContainerImageAssetMetadataEntry Metadata Entry spec for container images.
type ContainerImageAssetMetadataEntry struct {

  // Build args to pass to the `docker build` command (Default no build args are passed)
  BuildArgs map[string]string `json:"buildArgs,omitempty"`

  // Path to the Dockerfile (relative to the directory). (Default - no file is passed)
  File string `json:"file,omitempty"`

  // Logical identifier for the asset
  Id string `json:"id"`

  // ECR Repository name and repo digest (separated by "@sha256:") where this
  // image is stored. (Default undefined If not specified, `repositoryName` and `imageTag` are
  // required because otherwise how will the stack know where to find the asset,
  // ha?)
  ImageNameParameter string `json:"imageNameParameter,omitempty"`

  // The docker image tag to use for tagging pushed images. This field is
  // required if `imageParameterName` is ommited (otherwise, the app won't be
  // able to find the image). (Default - this parameter is REQUIRED after 1.21.0)
  ImageTag string `json:"imageTag,omitempty"`

  // Networking mode for the RUN commands during build. (Default - no networking mode specified)
  NetworkMode string `json:"networkMode,omitempty"`

  // Type of asset
  Packaging string `json:"packaging"`

  // Path on disk to the asset
  Path string `json:"path"`

  // Platform to build for. _Requires Docker Buildx_. (Default - current machine platform)
  Platform string `json:"platform,omitempty"`

  // ECR repository name, if omitted a default name based on the asset's ID is
  // used instead. Specify this property if you need to statically address the
  // image, e.g. from a Kubernetes Pod. Note, this is only the repository name,
  // without the registry and the tag parts. (Default - this parameter is REQUIRED after 1.21.0)
  RepositoryName string `json:"repositoryName,omitempty"`

  // The hash of the asset source.
  SourceHash string `json:"sourceHash"`

  // Docker target to build to (Default no build target)
  Target string `json:"target,omitempty"`
}

// EndpointServiceAvailabilityZonesContextQuery Query to endpoint service context provider
type EndpointServiceAvailabilityZonesContextQuery struct {

  // Query account
  Account string `json:"account"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Query region
  Region string `json:"region"`

  // Query service name
  ServiceName string `json:"serviceName"`
}

// FileAssetMetadataEntry Metadata Entry spec for files.
type FileAssetMetadataEntry struct {

  // The name of the parameter where the hash of the bundled asset should be passed in.
  ArtifactHashParameter string `json:"artifactHashParameter"`

  // Logical identifier for the asset
  Id string `json:"id"`

  // Requested packaging style
  Packaging string `json:"packaging"`

  // Path on disk to the asset
  Path string `json:"path"`

  // Name of parameter where S3 bucket should be passed in
  S3BucketParameter string `json:"s3BucketParameter"`

  // Name of parameter where S3 key should be passed in
  S3KeyParameter string `json:"s3KeyParameter"`

  // The hash of the asset source.
  SourceHash string `json:"sourceHash"`
}

// HostedZoneContextQuery Query to hosted zone context provider
type HostedZoneContextQuery struct {

  // Query account
  Account string `json:"account"`

  // The domain name e.g. example.com to lookup
  DomainName string `json:"domainName"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // True if the zone you want to find is a private hosted zone
  PrivateZone bool `json:"privateZone,omitempty"`

  // Query region
  Region string `json:"region"`

  // The VPC ID to that the private zone must be associated with
  // 
  // If you provide VPC ID and privateZone is false, this will return no results
  // and raise an error. (Default - Required if privateZone=true)
  VpcId string `json:"vpcId,omitempty"`
}

// KeyContextQuery Query input for looking up a KMS Key
type KeyContextQuery struct {

  // Query account
  Account string `json:"account"`

  // Alias name used to search the Key
  AliasName string `json:"aliasName"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Query region
  Region string `json:"region"`
}

// LoadBalancerContextQuery Query input for looking up a load balancer
type LoadBalancerContextQuery struct {

  // Query account
  Account string `json:"account"`

  // Find by load balancer's ARN (Default - does not search by load balancer arn)
  LoadBalancerArn string `json:"loadBalancerArn,omitempty"`

  // Match load balancer tags (Default - does not match load balancers by tags)
  LoadBalancerTags []*Tag `json:"loadBalancerTags,omitempty"`

  // Filter load balancers by their type
  LoadBalancerType string `json:"loadBalancerType"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Query region
  Region string `json:"region"`
}

// LoadBalancerListenerContextQuery Query input for looking up a load balancer listener
type LoadBalancerListenerContextQuery struct {

  // Query account
  Account string `json:"account"`

  // Find by listener's arn (Default - does not find by listener arn)
  ListenerArn string `json:"listenerArn,omitempty"`

  // Filter listeners by listener port (Default - does not filter by a listener port)
  ListenerPort float64 `json:"listenerPort,omitempty"`

  // Filter by listener protocol (Default - does not filter by listener protocol)
  ListenerProtocol string `json:"listenerProtocol,omitempty"`

  // Find by load balancer's ARN (Default - does not search by load balancer arn)
  LoadBalancerArn string `json:"loadBalancerArn,omitempty"`

  // Match load balancer tags (Default - does not match load balancers by tags)
  LoadBalancerTags []*Tag `json:"loadBalancerTags,omitempty"`

  // Filter load balancers by their type
  LoadBalancerType string `json:"loadBalancerType"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Query region
  Region string `json:"region"`
}

// MetadataEntry A metadata entry in a cloud assembly artifact.
type MetadataEntry struct {

  // The data. (Default - no data.)
  Data interface{} `json:"data,omitempty"`

  // A stack trace for when the entry was created. (Default - no trace.)
  Trace []string `json:"trace,omitempty"`

  // The type of the metadata entry.
  Type string `json:"type"`
}

// MissingContext Represents a missing piece of context.
type MissingContext struct {

  // The missing context key.
  Key string `json:"key"`

  // A set of provider-specific options.
  Props interface{} `json:"props"`

  // The provider from which we expect this context key to be obtained.
  Provider string `json:"provider"`
}

// NestedCloudAssemblyProperties Artifact properties for nested cloud assemblies
type NestedCloudAssemblyProperties struct {

  // Relative path to the nested cloud assembly
  DirectoryName string `json:"directoryName"`

  // Display name for the cloud assembly (Default - The artifact ID)
  DisplayName string `json:"displayName,omitempty"`
}

// PluginContextQuery Query input for plugins
// 
// This alternate branch is necessary because it needs to be able to escape all type checking
// we do on on the cloud assembly -- we cannot know the properties that will be used a priori.
type PluginContextQuery struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // The name of the plugin
  PluginName string `json:"pluginName"`
}

// RuntimeInfo Information about the application's runtime components.
type RuntimeInfo struct {

  // The list of libraries loaded in the application, associated with their versions.
  Libraries map[string]string `json:"libraries"`
}

// SSMParameterContextQuery Query to SSM Parameter Context Provider
type SSMParameterContextQuery struct {

  // Query account
  Account string `json:"account"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Parameter name to query
  ParameterName string `json:"parameterName"`

  // Query region
  Region string `json:"region"`
}

// SecurityGroupContextQuery Query input for looking up a security group
type SecurityGroupContextQuery struct {

  // Query account
  Account string `json:"account"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Query region
  Region string `json:"region"`

  // Security group id (Default - None)
  SecurityGroupId string `json:"securityGroupId,omitempty"`

  // Security group name (Default - None)
  SecurityGroupName string `json:"securityGroupName,omitempty"`

  // VPC ID (Default - None)
  VpcId string `json:"vpcId,omitempty"`
}

// Tag Metadata Entry spec for stack tag.
type Tag struct {

  // Tag key.
  // 
  // (In the actual file on disk this will be cased as "Key", and the structure is
  // patched to match this structure upon loading:
  // https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)
  Key string `json:"key"`

  // Tag value.
  // 
  // (In the actual file on disk this will be cased as "Value", and the structure is
  // patched to match this structure upon loading:
  // https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)
  Value string `json:"value"`
}

// TreeArtifactProperties Artifact properties for the Construct Tree Artifact
type TreeArtifactProperties struct {

  // Filename of the tree artifact
  File string `json:"file"`
}

// VpcContextQuery Query input for looking up a VPC
type VpcContextQuery struct {

  // Query account
  Account string `json:"account"`

  // Filters to apply to the VPC
  // 
  // Filter parameters are the same as passed to DescribeVpcs.
  Filter map[string]string `json:"filter"`

  // The ARN of the role that should be used to look up the missing values (Default - None)
  LookupRoleArn string `json:"lookupRoleArn,omitempty"`

  // Query region
  Region string `json:"region"`

  // Whether to populate the subnetGroups field of the{@linkVpcContextResponse},
  // which contains potentially asymmetric subnet groups.
  ReturnAsymmetricSubnets bool `json:"returnAsymmetricSubnets,omitempty"`

  // Optional tag for subnet group name.
  // If not provided, we'll look at the aws-cdk:subnet-name tag.
  // If the subnet does not have the specified tag,
  // we'll use its type as the name. (Default 'aws-cdk:subnet-name')
  SubnetGroupNameTag string `json:"subnetGroupNameTag,omitempty"`
}

func (strct *AmiContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Filters" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "filters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"filters\": ")
	if tmp, err := json.Marshal(strct.Filters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "owners" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"owners\": ")
	if tmp, err := json.Marshal(strct.Owners); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AmiContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    filtersReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "filters":
            if err := json.Unmarshal([]byte(v), &strct.Filters); err != nil {
                return err
             }
            filtersReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "owners":
            if err := json.Unmarshal([]byte(v), &strct.Owners); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if filters (a required property) was received
    if !filtersReceived {
        return errors.New("\"filters\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *ArtifactManifest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "dependencies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dependencies\": ")
	if tmp, err := json.Marshal(strct.Dependencies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "displayName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"displayName\": ")
	if tmp, err := json.Marshal(strct.DisplayName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "environment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "properties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ArtifactManifest) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dependencies":
            if err := json.Unmarshal([]byte(v), &strct.Dependencies); err != nil {
                return err
             }
        case "displayName":
            if err := json.Unmarshal([]byte(v), &strct.DisplayName); err != nil {
                return err
             }
        case "environment":
            if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
                return err
             }
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
                return err
             }
        case "properties":
            if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *AssemblyManifest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "artifacts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"artifacts\": ")
	if tmp, err := json.Marshal(strct.Artifacts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "missing" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"missing\": ")
	if tmp, err := json.Marshal(strct.Missing); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "runtime" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"runtime\": ")
	if tmp, err := json.Marshal(strct.Runtime); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssemblyManifest) UnmarshalJSON(b []byte) error {
    versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "artifacts":
            if err := json.Unmarshal([]byte(v), &strct.Artifacts); err != nil {
                return err
             }
        case "missing":
            if err := json.Unmarshal([]byte(v), &strct.Missing); err != nil {
                return err
             }
        case "runtime":
            if err := json.Unmarshal([]byte(v), &strct.Runtime); err != nil {
                return err
             }
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            versionReceived = true
        }
    }
    // check if version (a required property) was received
    if !versionReceived {
        return errors.New("\"version\" is required but was not present")
    }
    return nil
}

func (strct *AssetManifestProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "bootstrapStackVersionSsmParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"bootstrapStackVersionSsmParameter\": ")
	if tmp, err := json.Marshal(strct.BootstrapStackVersionSsmParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "File" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"file\": ")
	if tmp, err := json.Marshal(strct.File); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "requiresBootstrapStackVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"requiresBootstrapStackVersion\": ")
	if tmp, err := json.Marshal(strct.RequiresBootstrapStackVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AssetManifestProperties) UnmarshalJSON(b []byte) error {
    fileReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "bootstrapStackVersionSsmParameter":
            if err := json.Unmarshal([]byte(v), &strct.BootstrapStackVersionSsmParameter); err != nil {
                return err
             }
        case "file":
            if err := json.Unmarshal([]byte(v), &strct.File); err != nil {
                return err
             }
            fileReceived = true
        case "requiresBootstrapStackVersion":
            if err := json.Unmarshal([]byte(v), &strct.RequiresBootstrapStackVersion); err != nil {
                return err
             }
        }
    }
    // check if file (a required property) was received
    if !fileReceived {
        return errors.New("\"file\" is required but was not present")
    }
    return nil
}

func (strct *AvailabilityZonesContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AvailabilityZonesContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *AwsCloudFormationStackProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "assumeRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"assumeRoleArn\": ")
	if tmp, err := json.Marshal(strct.AssumeRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "assumeRoleExternalId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"assumeRoleExternalId\": ")
	if tmp, err := json.Marshal(strct.AssumeRoleExternalId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "bootstrapStackVersionSsmParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"bootstrapStackVersionSsmParameter\": ")
	if tmp, err := json.Marshal(strct.BootstrapStackVersionSsmParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "cloudFormationExecutionRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"cloudFormationExecutionRoleArn\": ")
	if tmp, err := json.Marshal(strct.CloudFormationExecutionRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRole" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRole\": ")
	if tmp, err := json.Marshal(strct.LookupRole); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "requiresBootstrapStackVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"requiresBootstrapStackVersion\": ")
	if tmp, err := json.Marshal(strct.RequiresBootstrapStackVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stackName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"stackName\": ")
	if tmp, err := json.Marshal(strct.StackName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stackTemplateAssetObjectUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"stackTemplateAssetObjectUrl\": ")
	if tmp, err := json.Marshal(strct.StackTemplateAssetObjectUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TemplateFile" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "templateFile" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"templateFile\": ")
	if tmp, err := json.Marshal(strct.TemplateFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "terminationProtection" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"terminationProtection\": ")
	if tmp, err := json.Marshal(strct.TerminationProtection); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "validateOnSynth" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"validateOnSynth\": ")
	if tmp, err := json.Marshal(strct.ValidateOnSynth); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AwsCloudFormationStackProperties) UnmarshalJSON(b []byte) error {
    templateFileReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "assumeRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.AssumeRoleArn); err != nil {
                return err
             }
        case "assumeRoleExternalId":
            if err := json.Unmarshal([]byte(v), &strct.AssumeRoleExternalId); err != nil {
                return err
             }
        case "bootstrapStackVersionSsmParameter":
            if err := json.Unmarshal([]byte(v), &strct.BootstrapStackVersionSsmParameter); err != nil {
                return err
             }
        case "cloudFormationExecutionRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.CloudFormationExecutionRoleArn); err != nil {
                return err
             }
        case "lookupRole":
            if err := json.Unmarshal([]byte(v), &strct.LookupRole); err != nil {
                return err
             }
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "requiresBootstrapStackVersion":
            if err := json.Unmarshal([]byte(v), &strct.RequiresBootstrapStackVersion); err != nil {
                return err
             }
        case "stackName":
            if err := json.Unmarshal([]byte(v), &strct.StackName); err != nil {
                return err
             }
        case "stackTemplateAssetObjectUrl":
            if err := json.Unmarshal([]byte(v), &strct.StackTemplateAssetObjectUrl); err != nil {
                return err
             }
        case "tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "templateFile":
            if err := json.Unmarshal([]byte(v), &strct.TemplateFile); err != nil {
                return err
             }
            templateFileReceived = true
        case "terminationProtection":
            if err := json.Unmarshal([]byte(v), &strct.TerminationProtection); err != nil {
                return err
             }
        case "validateOnSynth":
            if err := json.Unmarshal([]byte(v), &strct.ValidateOnSynth); err != nil {
                return err
             }
        }
    }
    // check if templateFile (a required property) was received
    if !templateFileReceived {
        return errors.New("\"templateFile\" is required but was not present")
    }
    return nil
}

func (strct *BootstrapRole) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arn" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "arn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"arn\": ")
	if tmp, err := json.Marshal(strct.Arn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "assumeRoleExternalId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"assumeRoleExternalId\": ")
	if tmp, err := json.Marshal(strct.AssumeRoleExternalId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "bootstrapStackVersionSsmParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"bootstrapStackVersionSsmParameter\": ")
	if tmp, err := json.Marshal(strct.BootstrapStackVersionSsmParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "requiresBootstrapStackVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"requiresBootstrapStackVersion\": ")
	if tmp, err := json.Marshal(strct.RequiresBootstrapStackVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BootstrapRole) UnmarshalJSON(b []byte) error {
    arnReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "arn":
            if err := json.Unmarshal([]byte(v), &strct.Arn); err != nil {
                return err
             }
            arnReceived = true
        case "assumeRoleExternalId":
            if err := json.Unmarshal([]byte(v), &strct.AssumeRoleExternalId); err != nil {
                return err
             }
        case "bootstrapStackVersionSsmParameter":
            if err := json.Unmarshal([]byte(v), &strct.BootstrapStackVersionSsmParameter); err != nil {
                return err
             }
        case "requiresBootstrapStackVersion":
            if err := json.Unmarshal([]byte(v), &strct.RequiresBootstrapStackVersion); err != nil {
                return err
             }
        }
    }
    // check if arn (a required property) was received
    if !arnReceived {
        return errors.New("\"arn\" is required but was not present")
    }
    return nil
}

func (strct *ContainerImageAssetMetadataEntry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "buildArgs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"buildArgs\": ")
	if tmp, err := json.Marshal(strct.BuildArgs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"file\": ")
	if tmp, err := json.Marshal(strct.File); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "imageNameParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"imageNameParameter\": ")
	if tmp, err := json.Marshal(strct.ImageNameParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "imageTag" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"imageTag\": ")
	if tmp, err := json.Marshal(strct.ImageTag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "networkMode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"networkMode\": ")
	if tmp, err := json.Marshal(strct.NetworkMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Packaging" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "packaging" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"packaging\": ")
	if tmp, err := json.Marshal(strct.Packaging); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Path" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "platform" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"platform\": ")
	if tmp, err := json.Marshal(strct.Platform); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "repositoryName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"repositoryName\": ")
	if tmp, err := json.Marshal(strct.RepositoryName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sourceHash" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sourceHash\": ")
	if tmp, err := json.Marshal(strct.SourceHash); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "target" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"target\": ")
	if tmp, err := json.Marshal(strct.Target); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContainerImageAssetMetadataEntry) UnmarshalJSON(b []byte) error {
    idReceived := false
    packagingReceived := false
    pathReceived := false
    sourceHashReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "buildArgs":
            if err := json.Unmarshal([]byte(v), &strct.BuildArgs); err != nil {
                return err
             }
        case "file":
            if err := json.Unmarshal([]byte(v), &strct.File); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "imageNameParameter":
            if err := json.Unmarshal([]byte(v), &strct.ImageNameParameter); err != nil {
                return err
             }
        case "imageTag":
            if err := json.Unmarshal([]byte(v), &strct.ImageTag); err != nil {
                return err
             }
        case "networkMode":
            if err := json.Unmarshal([]byte(v), &strct.NetworkMode); err != nil {
                return err
             }
        case "packaging":
            if err := json.Unmarshal([]byte(v), &strct.Packaging); err != nil {
                return err
             }
            packagingReceived = true
        case "path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
            pathReceived = true
        case "platform":
            if err := json.Unmarshal([]byte(v), &strct.Platform); err != nil {
                return err
             }
        case "repositoryName":
            if err := json.Unmarshal([]byte(v), &strct.RepositoryName); err != nil {
                return err
             }
        case "sourceHash":
            if err := json.Unmarshal([]byte(v), &strct.SourceHash); err != nil {
                return err
             }
            sourceHashReceived = true
        case "target":
            if err := json.Unmarshal([]byte(v), &strct.Target); err != nil {
                return err
             }
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if packaging (a required property) was received
    if !packagingReceived {
        return errors.New("\"packaging\" is required but was not present")
    }
    // check if path (a required property) was received
    if !pathReceived {
        return errors.New("\"path\" is required but was not present")
    }
    // check if sourceHash (a required property) was received
    if !sourceHashReceived {
        return errors.New("\"sourceHash\" is required but was not present")
    }
    return nil
}

func (strct *EndpointServiceAvailabilityZonesContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ServiceName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "serviceName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"serviceName\": ")
	if tmp, err := json.Marshal(strct.ServiceName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EndpointServiceAvailabilityZonesContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    regionReceived := false
    serviceNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        case "serviceName":
            if err := json.Unmarshal([]byte(v), &strct.ServiceName); err != nil {
                return err
             }
            serviceNameReceived = true
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    // check if serviceName (a required property) was received
    if !serviceNameReceived {
        return errors.New("\"serviceName\" is required but was not present")
    }
    return nil
}

func (strct *FileAssetMetadataEntry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ArtifactHashParameter" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "artifactHashParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"artifactHashParameter\": ")
	if tmp, err := json.Marshal(strct.ArtifactHashParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Packaging" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "packaging" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"packaging\": ")
	if tmp, err := json.Marshal(strct.Packaging); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Path" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3BucketParameter" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "s3BucketParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"s3BucketParameter\": ")
	if tmp, err := json.Marshal(strct.S3BucketParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "S3KeyParameter" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "s3KeyParameter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"s3KeyParameter\": ")
	if tmp, err := json.Marshal(strct.S3KeyParameter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SourceHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sourceHash" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sourceHash\": ")
	if tmp, err := json.Marshal(strct.SourceHash); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileAssetMetadataEntry) UnmarshalJSON(b []byte) error {
    artifactHashParameterReceived := false
    idReceived := false
    packagingReceived := false
    pathReceived := false
    s3BucketParameterReceived := false
    s3KeyParameterReceived := false
    sourceHashReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "artifactHashParameter":
            if err := json.Unmarshal([]byte(v), &strct.ArtifactHashParameter); err != nil {
                return err
             }
            artifactHashParameterReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "packaging":
            if err := json.Unmarshal([]byte(v), &strct.Packaging); err != nil {
                return err
             }
            packagingReceived = true
        case "path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
            pathReceived = true
        case "s3BucketParameter":
            if err := json.Unmarshal([]byte(v), &strct.S3BucketParameter); err != nil {
                return err
             }
            s3BucketParameterReceived = true
        case "s3KeyParameter":
            if err := json.Unmarshal([]byte(v), &strct.S3KeyParameter); err != nil {
                return err
             }
            s3KeyParameterReceived = true
        case "sourceHash":
            if err := json.Unmarshal([]byte(v), &strct.SourceHash); err != nil {
                return err
             }
            sourceHashReceived = true
        }
    }
    // check if artifactHashParameter (a required property) was received
    if !artifactHashParameterReceived {
        return errors.New("\"artifactHashParameter\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if packaging (a required property) was received
    if !packagingReceived {
        return errors.New("\"packaging\" is required but was not present")
    }
    // check if path (a required property) was received
    if !pathReceived {
        return errors.New("\"path\" is required but was not present")
    }
    // check if s3BucketParameter (a required property) was received
    if !s3BucketParameterReceived {
        return errors.New("\"s3BucketParameter\" is required but was not present")
    }
    // check if s3KeyParameter (a required property) was received
    if !s3KeyParameterReceived {
        return errors.New("\"s3KeyParameter\" is required but was not present")
    }
    // check if sourceHash (a required property) was received
    if !sourceHashReceived {
        return errors.New("\"sourceHash\" is required but was not present")
    }
    return nil
}

func (strct *HostedZoneContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DomainName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "domainName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"domainName\": ")
	if tmp, err := json.Marshal(strct.DomainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "privateZone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"privateZone\": ")
	if tmp, err := json.Marshal(strct.PrivateZone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "vpcId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"vpcId\": ")
	if tmp, err := json.Marshal(strct.VpcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HostedZoneContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    domainNameReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "domainName":
            if err := json.Unmarshal([]byte(v), &strct.DomainName); err != nil {
                return err
             }
            domainNameReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "privateZone":
            if err := json.Unmarshal([]byte(v), &strct.PrivateZone); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        case "vpcId":
            if err := json.Unmarshal([]byte(v), &strct.VpcId); err != nil {
                return err
             }
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if domainName (a required property) was received
    if !domainNameReceived {
        return errors.New("\"domainName\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *KeyContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AliasName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "aliasName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"aliasName\": ")
	if tmp, err := json.Marshal(strct.AliasName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KeyContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    aliasNameReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "aliasName":
            if err := json.Unmarshal([]byte(v), &strct.AliasName); err != nil {
                return err
             }
            aliasNameReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if aliasName (a required property) was received
    if !aliasNameReceived {
        return errors.New("\"aliasName\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *LoadBalancerContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "loadBalancerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loadBalancerArn\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "loadBalancerTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loadBalancerTags\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LoadBalancerType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "loadBalancerType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loadBalancerType\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoadBalancerContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    loadBalancerTypeReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "loadBalancerArn":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerArn); err != nil {
                return err
             }
        case "loadBalancerTags":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerTags); err != nil {
                return err
             }
        case "loadBalancerType":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerType); err != nil {
                return err
             }
            loadBalancerTypeReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if loadBalancerType (a required property) was received
    if !loadBalancerTypeReceived {
        return errors.New("\"loadBalancerType\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *LoadBalancerListenerContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "listenerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"listenerArn\": ")
	if tmp, err := json.Marshal(strct.ListenerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "listenerPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"listenerPort\": ")
	if tmp, err := json.Marshal(strct.ListenerPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "listenerProtocol" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"listenerProtocol\": ")
	if tmp, err := json.Marshal(strct.ListenerProtocol); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "loadBalancerArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loadBalancerArn\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "loadBalancerTags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loadBalancerTags\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerTags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LoadBalancerType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "loadBalancerType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loadBalancerType\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoadBalancerListenerContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    loadBalancerTypeReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "listenerArn":
            if err := json.Unmarshal([]byte(v), &strct.ListenerArn); err != nil {
                return err
             }
        case "listenerPort":
            if err := json.Unmarshal([]byte(v), &strct.ListenerPort); err != nil {
                return err
             }
        case "listenerProtocol":
            if err := json.Unmarshal([]byte(v), &strct.ListenerProtocol); err != nil {
                return err
             }
        case "loadBalancerArn":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerArn); err != nil {
                return err
             }
        case "loadBalancerTags":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerTags); err != nil {
                return err
             }
        case "loadBalancerType":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerType); err != nil {
                return err
             }
            loadBalancerTypeReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if loadBalancerType (a required property) was received
    if !loadBalancerTypeReceived {
        return errors.New("\"loadBalancerType\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *MetadataEntry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "data" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"data\": ")
	if tmp, err := json.Marshal(strct.Data); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "trace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"trace\": ")
	if tmp, err := json.Marshal(strct.Trace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetadataEntry) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "data":
            if err := json.Unmarshal([]byte(v), &strct.Data); err != nil {
                return err
             }
        case "trace":
            if err := json.Unmarshal([]byte(v), &strct.Trace); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *MissingContext) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Props" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "props" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"props\": ")
	if tmp, err := json.Marshal(strct.Props); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Provider" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "provider" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"provider\": ")
	if tmp, err := json.Marshal(strct.Provider); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MissingContext) UnmarshalJSON(b []byte) error {
    keyReceived := false
    propsReceived := false
    providerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            keyReceived = true
        case "props":
            if err := json.Unmarshal([]byte(v), &strct.Props); err != nil {
                return err
             }
            propsReceived = true
        case "provider":
            if err := json.Unmarshal([]byte(v), &strct.Provider); err != nil {
                return err
             }
            providerReceived = true
        }
    }
    // check if key (a required property) was received
    if !keyReceived {
        return errors.New("\"key\" is required but was not present")
    }
    // check if props (a required property) was received
    if !propsReceived {
        return errors.New("\"props\" is required but was not present")
    }
    // check if provider (a required property) was received
    if !providerReceived {
        return errors.New("\"provider\" is required but was not present")
    }
    return nil
}

func (strct *NestedCloudAssemblyProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DirectoryName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "directoryName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"directoryName\": ")
	if tmp, err := json.Marshal(strct.DirectoryName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "displayName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"displayName\": ")
	if tmp, err := json.Marshal(strct.DisplayName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NestedCloudAssemblyProperties) UnmarshalJSON(b []byte) error {
    directoryNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "directoryName":
            if err := json.Unmarshal([]byte(v), &strct.DirectoryName); err != nil {
                return err
             }
            directoryNameReceived = true
        case "displayName":
            if err := json.Unmarshal([]byte(v), &strct.DisplayName); err != nil {
                return err
             }
        }
    }
    // check if directoryName (a required property) was received
    if !directoryNameReceived {
        return errors.New("\"directoryName\" is required but was not present")
    }
    return nil
}

func (strct *PluginContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PluginName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "pluginName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pluginName\": ")
	if tmp, err := json.Marshal(strct.PluginName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PluginContextQuery) UnmarshalJSON(b []byte) error {
    pluginNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "pluginName":
            if err := json.Unmarshal([]byte(v), &strct.PluginName); err != nil {
                return err
             }
            pluginNameReceived = true
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    // check if pluginName (a required property) was received
    if !pluginNameReceived {
        return errors.New("\"pluginName\" is required but was not present")
    }
    return nil
}

func (strct *RuntimeInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Libraries" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "libraries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"libraries\": ")
	if tmp, err := json.Marshal(strct.Libraries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RuntimeInfo) UnmarshalJSON(b []byte) error {
    librariesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "libraries":
            if err := json.Unmarshal([]byte(v), &strct.Libraries); err != nil {
                return err
             }
            librariesReceived = true
        }
    }
    // check if libraries (a required property) was received
    if !librariesReceived {
        return errors.New("\"libraries\" is required but was not present")
    }
    return nil
}

func (strct *SSMParameterContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ParameterName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parameterName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameterName\": ")
	if tmp, err := json.Marshal(strct.ParameterName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SSMParameterContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    parameterNameReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "parameterName":
            if err := json.Unmarshal([]byte(v), &strct.ParameterName); err != nil {
                return err
             }
            parameterNameReceived = true
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if parameterName (a required property) was received
    if !parameterNameReceived {
        return errors.New("\"parameterName\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *SecurityGroupContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securityGroupId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securityGroupId\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securityGroupName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securityGroupName\": ")
	if tmp, err := json.Marshal(strct.SecurityGroupName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "vpcId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"vpcId\": ")
	if tmp, err := json.Marshal(strct.VpcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecurityGroupContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        case "securityGroupId":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupId); err != nil {
                return err
             }
        case "securityGroupName":
            if err := json.Unmarshal([]byte(v), &strct.SecurityGroupName); err != nil {
                return err
             }
        case "vpcId":
            if err := json.Unmarshal([]byte(v), &strct.VpcId); err != nil {
                return err
             }
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    keyReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            keyReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            valueReceived = true
        }
    }
    // check if key (a required property) was received
    if !keyReceived {
        return errors.New("\"key\" is required but was not present")
    }
    // check if value (a required property) was received
    if !valueReceived {
        return errors.New("\"value\" is required but was not present")
    }
    return nil
}

func (strct *TreeArtifactProperties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "File" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"file\": ")
	if tmp, err := json.Marshal(strct.File); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TreeArtifactProperties) UnmarshalJSON(b []byte) error {
    fileReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "file":
            if err := json.Unmarshal([]byte(v), &strct.File); err != nil {
                return err
             }
            fileReceived = true
        }
    }
    // check if file (a required property) was received
    if !fileReceived {
        return errors.New("\"file\" is required but was not present")
    }
    return nil
}

func (strct *VpcContextQuery) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Account" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Filter" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "filter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"filter\": ")
	if tmp, err := json.Marshal(strct.Filter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lookupRoleArn" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lookupRoleArn\": ")
	if tmp, err := json.Marshal(strct.LookupRoleArn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Region" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "returnAsymmetricSubnets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"returnAsymmetricSubnets\": ")
	if tmp, err := json.Marshal(strct.ReturnAsymmetricSubnets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "subnetGroupNameTag" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"subnetGroupNameTag\": ")
	if tmp, err := json.Marshal(strct.SubnetGroupNameTag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VpcContextQuery) UnmarshalJSON(b []byte) error {
    accountReceived := false
    filterReceived := false
    regionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
                return err
             }
            accountReceived = true
        case "filter":
            if err := json.Unmarshal([]byte(v), &strct.Filter); err != nil {
                return err
             }
            filterReceived = true
        case "lookupRoleArn":
            if err := json.Unmarshal([]byte(v), &strct.LookupRoleArn); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
            regionReceived = true
        case "returnAsymmetricSubnets":
            if err := json.Unmarshal([]byte(v), &strct.ReturnAsymmetricSubnets); err != nil {
                return err
             }
        case "subnetGroupNameTag":
            if err := json.Unmarshal([]byte(v), &strct.SubnetGroupNameTag); err != nil {
                return err
             }
        }
    }
    // check if account (a required property) was received
    if !accountReceived {
        return errors.New("\"account\" is required but was not present")
    }
    // check if filter (a required property) was received
    if !filterReceived {
        return errors.New("\"filter\" is required but was not present")
    }
    // check if region (a required property) was received
    if !regionReceived {
        return errors.New("\"region\" is required but was not present")
    }
    return nil
}
